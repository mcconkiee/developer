---
layout: page
title: "iOS SDK"
category: doc
date: 2015-01-22 16:05:00
---
# Overview
The iOS SDK offers developers an object oriented library by which on can communicate directly with a Poynt Smart Terminal using an iOS compatible device. Currently the SDK supports systems running >= iOS 8. 
<hr>
## Key Components

### [PoyntPOSConnectionManager](/developer/ios-sdk/html/interface_poynt_p_o_s_connection_manager.html)
The `PoyntPOSConnectionManager` sets the stage for communicating with a Poynt Smart Termnial. The only required paramters are the ip address of the terminal and the paring code generated by the terminal. This implies that the iOS device must be on the same WiFi network as the terminal. The iOS SDK does offer an automatic way to discover Poynt terminals on the same network. See the [`PoyntTerminalDiscover`](/developer/ios-sdk/html/interface_poynt_terminal_discover.html) for more details.	

### [PoyntPaymentObject](/developer/ios-sdk/html/interface_poynt_payment_object.html)
Use `PoyntPaymentObject` to create a new payment transaction. This object describes the overall understanding of the transaction from totals, subtotals, discounts, currency, etc. It's most commonly coupled with a [`PoyntOrderObject`](/developer/ios-sdk/html/interface_poynt_order_object.html).

Common use cases would be selling a ticket at the door, or building an order at a cafe.

### [PoyntTransactionObject](/developer/ios-sdk/html/interface_poynt_transaction_object.html)
Because this object ALWAYS has a `transactionId`, it is most commonly used in cases when you will modify an existing object from Poynt Services

<hr>
## Getting Started
There is a [sample application](https://github.com/poynt/pos-connector-ios-sdk-sample) demonstrating a Swift implementation of the SDK.

### Installing
The SDK is written in Objective C. Therefore, it requires you add to your project [the binary and it's respective headder files](https://github.com/poynt/pos-connector-ios-sdk-sample/tree/master/PoyntLib). If your project is using Swift, you will also need a [bridge file](https://github.com/poynt/pos-connector-ios-sdk-sample/blob/master/iOStoPOSExample/iOStoPOSExample-Bridging-Header.h).

There is also an unofficial cocoapod implementation [here](https://github.com/mcconkiee/poyntsdk)

### Connect to your terminal
Before you can interact with the terminal, you must first identify and authorize your iOS client with a terminal. We've provided two ways to accomplish this:

* automatic discovery
* manual 


#### Automatic Discovery
Letting `PoyntTerminalDiscover` object do all the work, simply create, and find. A callback will return an array of `PoyntTerminal` objects, each identifying their own ip, url, and name. 

```
let posConnectionManager =  PoyntPOSConnectionManager()
posConnectionManager.onTransactionResponse = {(transactionObect ,apiType) -> Void in
		self.updateUI()
    }
}

let discovery = PoyntTerminalDiscover()
discovery.findTerminals { (terminals) in
    if let terms = terminals as? [PoyntTerminal] {
    	
    	//confirm the terminal is populated as expected...
        if let terminal = terms.first as PoyntTerminal?,
            let ip = terminal.ip as String?,
            let port = terminal.service?.port as Int? { 
            
            //config the PoyntPOSConnectionManager              
	            let addy = "\(ip):\(port)"
	            self.posConnectionManager.url = addy
	            posConnectionManager.authorizePairing("ABC123")
	            	          
        }
    }
}
```        
#### Manual
The manual process is much like the `addy` assignment in the above `findTerminals` block. It assumes you already know the ip and pairing code. Simply assign the address and code to your connection manager object, and `authorizePairing`

### Create & Send a payment 
The most common use case is creating and sending a payment object. We can imagine a scenario where a merchant creates a payment for 3 cups of coffee. In this example, we will write the setup using Swift

```
//set up a payment transaction object to hold our items
let payment = PoyntPaymentObject()
payment.currency = "USD"
payment.tipAmount = 0        
payment.disableTip = false
payment.multiTender = false

//add order object to the transaction
payment.order = PoyntOrderObject()
payment.order?.notes =  "i am a note"

//add items to the order object (3 cups of coffee, $1 each)
let item0 = PoyntOrderItemObject(sku: "com.merchant.coffee", unitPrice: 100, quantity: 3.0)
item0.name = "Drip Coffee"
item0.unitOfMeasure = EACH
item0.status = "ORDERED"

// (optional) add a $2 discount to an item for loyalty!
item0.discounts = [PoyntDiscountObject(amount: 200, customName: "Loyalty discount")]

// (optional) add tax to the item
item0.taxes = [PoyntOrderItemTax(amount:100,type: "Plastic lids")]

//add the items to the order
payment.order?.items = [item0]
payment.amounts?.currency = "USD"
```        

Once the payment is created with the desired items, discounts, and taxes, we are ready to send it off to the terminal. However, before doing so, you will want to set the stage for the `PoyntPOSConnectionManager`'s response. There are two callbacks to implement: onError, and onTransactionResponse

```
//...because nothing is perfect, be ready for errors
posConnectionManager.onError = {(error, apiType) -> Void in
    
    // Don't Panic... I'm sure there is a good explanation for this...
    
}

//the request was successful
posConnectionManager.onTransactionResponse = {(transactionObect ,apiType) -> Void in
    
    //SUCCESS - update ui, high five your fellow engineers!    
    self.latestTransaction = transactionObject
    }
}
```

```
//send a payment
self.posConnectionManager.authorizeSales(payment)
```

### Modify an existing transaction
Now that we've completed our payment, we can capture, void, or take other actions on this transaction object using its `transactionId`. In this example, we will capture the transaction object:

```
//add sample code
self.posConnectionManager.authorizeCapture(self.latestTransaction)
```
<hr>
## Wrapping Up
Take some time to get familiar with the docs. We've only touched on the basics, but one will find there are many ways to interact with transactions and payments.	